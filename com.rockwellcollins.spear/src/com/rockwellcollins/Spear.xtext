grammar com.rockwellcollins.Spear with org.eclipse.xtext.common.Terminals

generate spear "http://www.rockwellcollins.com/Spear"

File:
	Specification | Definitions;

Specification:
	'Specification' (name=ID)
	('Imports:' imports+=Import*)?
	('Units:' units+=UnitDef*)?
	('Types:' typedefs+=TypeDef*)?
	('Constants:' constants+=Constant*)?
	('Patterns:' patterns+=Pattern*)?
	'Inputs:' inputs+=Variable*
	'Outputs:' outputs+=Variable*
	('State:' state+=Variable*)?
	('Macros:' macros+=Macro*)?
	(assumptionsKeyword=AssumptionsHeader ':' assumptions+=Constraint*)?
	requirementsKeyword=RequirementsHeader ':' requirements+=Constraint*
	(propertiesKeyword=PropertiesHeader ':' behaviors+=Constraint*)?;

AssumptionsHeader:
	'Assumptions' | 'Environment'
;

RequirementsHeader:
	'DerivedRequirements' | 'Requirements' | 'Implementation' | 'Design' | 'Constraints'
;

PropertiesHeader:
	'Requirements' | 'Properties' | 'Guarantees' | 'Behaviors'
;

Import:
	'import' importURI=STRING;

Definitions:
	'Definitions' (name=ID)
	('Imports:' imports+=Import*)?
	('Units:' unitdefs+=UnitDef*)?
	('Types:' typedefs+=TypeDef*)?
	('Constants:' constants+=Constant*)?
	('Patterns:' patterns+=Pattern*)?;

Pattern:
	'pattern' (name=ID) '(' (inputs+=Variable (',' inputs+=Variable)*)? ')' 'returns' '(' (outputs+=Variable (',' outputs+=Variable)*)? ')'
	 ('var' (locals+=Variable)* )?
	 'let' 
	 	( equations+=LustreEquation
	 	| properties+=LustreProperty
	 	| assertions+=LustreAssertion
	 	)*
	 'tel'
;

LustreEquation:
	'|' ids+=[Variable] (',' ids+=[Variable])* '|' '=' rhs=Expr
|	ids+=[Variable] '=' rhs=Expr
;

LustreProperty:
	'--%PROPERTY' propertyId=[Variable]
;

LustreAssertion:
	'assert' assertionExpr=Expr
;

UnitDef:
	{BaseUnit} name=ID (description=STRING)?
	| {DerivedUnit} name=ID IdTypeDelimiter unit=UnitExpr (description=STRING)?;

UnitExpr:
	ProductUnitExpr;

ProductUnitExpr returns UnitExpr:
	DivisionUnitExpr (=> ({BinaryUnitExpr.left=current} op='*') right=ProductUnitExpr)?;

DivisionUnitExpr returns UnitExpr:
	AtomicUnitExpr (=> ({BinaryUnitExpr.left=current} op='/') right=AtomicUnitExpr)?;

AtomicUnitExpr returns UnitExpr:
	{NamedUnitExpr} unit=[UnitDef]
	| '(' UnitExpr ')';

TypeDef:
	  {NamedTypeDef} name=ID IdTypeDelimiter type=Type (unit=[UnitDef])?
	| {AbstractTypeDef} name=ID IdTypeDelimiter 'abstract'
	| {RecordTypeDef} name=ID IdTypeDelimiter 'record' '{' fields+=FieldType (',' fields+=FieldType)* '}'
	| {ArrayTypeDef} name=ID IdTypeDelimiter base=Type '[' size=Expr ']'
	| {EnumTypeDef} name=ID IdTypeDelimiter 'enum' '{' values+=EnumValue (',' values+=EnumValue)* '}';
	
UnusedTypeDef returns TypeDef:
	{ConcreteArrayTypeDef} name=ID IdTypeDelimiter base=Type '[' size=INT ']'
;

FieldType:
	name=ID ':' type=Type;

EnumValue:
	name=ID;

Type:
	{IntType} 'int'
	| {BoolType} 'bool'
	| {RealType} 'real'
	| {UserType} def=[TypeDef];

IdTypeDelimiter:
	':'
	| 'is a'
	| 'is an';

Constant:
	name=ID IdTypeDelimiter type=Type '=' expr=Expr ('text' '=' descriptor=STRING)?;

Variable:
	name=ID IdTypeDelimiter type=Type;

Macro:
	name=ID IdTypeDelimiter type=Type '=' expr=Expr ('text' '=' descriptor=STRING)?;

Constraint:
	FormalConstraint | EnglishConstraint;

FormalConstraint:
	name=ID ':' expr=Expr ('text' '=' descriptor=STRING)?;

EnglishConstraint:
	name=ID ':' text=STRING;

/* Begin Expr Language */
Expr:
	WhileExpr;

WhileExpr returns Expr:
	{WhileExpr} 'while' cond=Expr 'then' then=Expr
|	 ImpliesExpr
;

ImpliesExpr returns Expr:
	OrExpr (=> ({BinaryExpr.left=current} op=('=>' | 'implies')) right=ImpliesExpr)?;

OrExpr returns Expr:
	AndExpr (=> ({BinaryExpr.left=current} op=('or' | 'xor')) right=OrExpr)?;

AndExpr returns Expr:
	AfterUntilExpr (=> ({BinaryExpr.left=current} op='and') right=AndExpr)?;

AfterUntilExpr returns Expr:
	{AfterUntilExpr} 'after' (after=TriggersExpr) (=> 'until' until=TriggersExpr)?
|	TriggersExpr
;

TriggersExpr returns Expr:
	SinceExpr (=> ({BinaryExpr.left=current} op=('T' | 'triggers')) right=TriggersExpr)?;

SinceExpr returns Expr:
	TemporalPrefixExpr (=> ({BinaryExpr.left=current} op=('S' | 'since')) right=SinceExpr)?;

TemporalPrefixExpr returns Expr:
	{UnaryExpr} op=('O' | 'once' | 'H' | 'historically' | 'never' | 'before' | 'initially') expr=TemporalPrefixExpr
	| RelationalExpr;

RelationalExpr returns Expr:
	PlusExpr (=> ({BinaryExpr.left=current} op=RelationalOp) right=RelationalExpr)?;

RelationalOp:
	   '<' | 'less' 'than'
	| '<=' | 'less' 'than' 'or' 'equal' 'to'
	| '>'  | 'greater' 'than'
	| '>=' | 'greater' 'than' 'or' 'equal' 'to'
	| '==' | 'equal' 'to'
	| '<>' | 'not' 'equal' 'to';

PlusExpr returns Expr:
	MultiplyExpr (=> ({BinaryExpr.left=current} op=('+' | '-')) right=PlusExpr)?;

MultiplyExpr returns Expr:
	ArrowExpr (=> ({BinaryExpr.left=current} op=('*' | '/' | 'mod')) right=MultiplyExpr)?;

ArrowExpr returns Expr:
	PrefixExpr (=> ({BinaryExpr.left=current} op=('->' | 'arrow')) right=ArrowExpr)?;

PrefixExpr returns Expr:
	{UnaryExpr} op=('-' | 'not') expr=PrefixExpr
	| {PreviousExpr} 'previous' var=PrefixExpr (=> 'with' 'initial' 'value' init=PrefixExpr)?
	| AccessExpr;

AccessExpr returns Expr:
	AtomicExpr (=> ({RecordAccessExpr.record=current} '.') field=[FieldType]
	| => ({RecordUpdateExpr.record=current} '{' field=[FieldType] ':=') value=Expr '}'
	| => ({ArrayAccessExpr.array=current} '[') index=Expr (=> ({ArrayUpdateExpr.access=current} ':=') value=Expr)? ']')*;

AtomicExpr returns Expr:
	LiteralExpr
	| {IdExpr} id=[IdRef]
	| {MultipleIdExpr} '|' ids+=[IdRef] (',' ids+=[IdRef])* '|'
	| {IfThenElseExpr} 'if' cond=Expr 'then' then=Expr (=> 'else' else=Expr)?
	| {RecordExpr} 'new' type=[RecordTypeDef] '{' fieldExprs+=FieldExpr (',' fieldExprs+=FieldExpr)* '}'
	| {FieldlessRecordExpr} 'new' type=[RecordTypeDef] '{' exprs+=Expr (',' exprs+=Expr)* '}'
	| {ArrayExpr} 'new' type=[ArrayTypeDef] '[' exprs+=Expr (',' exprs+=Expr)* ']'
	| {PatternCall} pattern=[Pattern] '(' ( args+=Expr (',' args+=Expr)* )? ')'
	| {SpecificationCall} 'spec' spec=[Specification] '(' ( args+=Expr (',' args+=Expr)* )? ')'
	| UnusedExpr
	| '(' Expr ')'
;

LiteralExpr:
	{IntLiteral} value=INT (unit=[UnitDef])?
	| {BoolLiteral} value=BOOL
	| {RealLiteral} value=REAL (unit=[UnitDef])?;

//	//this is a cute little hack to make processing easier on the translation to Lustre
UnusedExpr returns Expr:
	{NormalizedCall} '#' ids+=[IdRef] (',' ids+=[IdRef])* '#' '==' 'spec' spec=[Specification] '(' args+=Expr (',' args+=Expr)* ')';

IdRef:
	Variable
	| Macro
	| Constant
	| EnumValue;

FieldExpr:
	field=[FieldType] '=' expr=Expr;

BOOL:
	BOOLEAN_TRUE | BOOLEAN_FALSE;

BOOLEAN_TRUE:
	'TRUE' | 'true';

BOOLEAN_FALSE:
	'FALSE' | 'false';

REAL:
	INT '.' INT;

