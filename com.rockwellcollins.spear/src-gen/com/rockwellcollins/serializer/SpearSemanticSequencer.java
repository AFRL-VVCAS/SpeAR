/*
 * generated by Xtext
 */
package com.rockwellcollins.serializer;

import com.google.inject.Inject;
import com.rockwellcollins.services.SpearGrammarAccess;
import com.rockwellcollins.spear.AfterUntilExpr;
import com.rockwellcollins.spear.ArrayAccessExpr;
import com.rockwellcollins.spear.ArrayExpr;
import com.rockwellcollins.spear.ArrayTypeDef;
import com.rockwellcollins.spear.ArrayUpdateExpr;
import com.rockwellcollins.spear.BaseUnit;
import com.rockwellcollins.spear.BinaryExpr;
import com.rockwellcollins.spear.BinaryUnitExpr;
import com.rockwellcollins.spear.BoolLiteral;
import com.rockwellcollins.spear.BoolType;
import com.rockwellcollins.spear.Constant;
import com.rockwellcollins.spear.Definitions;
import com.rockwellcollins.spear.DerivedUnit;
import com.rockwellcollins.spear.EnglishConstraint;
import com.rockwellcollins.spear.EnumTypeDef;
import com.rockwellcollins.spear.EnumValue;
import com.rockwellcollins.spear.FieldExpr;
import com.rockwellcollins.spear.FieldType;
import com.rockwellcollins.spear.FieldlessRecordExpr;
import com.rockwellcollins.spear.FormalConstraint;
import com.rockwellcollins.spear.IdExpr;
import com.rockwellcollins.spear.IfThenElseExpr;
import com.rockwellcollins.spear.Import;
import com.rockwellcollins.spear.IntLiteral;
import com.rockwellcollins.spear.IntType;
import com.rockwellcollins.spear.LustreEquation;
import com.rockwellcollins.spear.MIdExpr;
import com.rockwellcollins.spear.Macro;
import com.rockwellcollins.spear.NamedTypeDef;
import com.rockwellcollins.spear.NamedUnitExpr;
import com.rockwellcollins.spear.NormalizedCall;
import com.rockwellcollins.spear.Pattern;
import com.rockwellcollins.spear.PatternCall;
import com.rockwellcollins.spear.PreviousExpr;
import com.rockwellcollins.spear.RealLiteral;
import com.rockwellcollins.spear.RealType;
import com.rockwellcollins.spear.RecordAccessExpr;
import com.rockwellcollins.spear.RecordExpr;
import com.rockwellcollins.spear.RecordTypeDef;
import com.rockwellcollins.spear.RecordUpdateExpr;
import com.rockwellcollins.spear.SpearPackage;
import com.rockwellcollins.spear.Specification;
import com.rockwellcollins.spear.SpecificationCall;
import com.rockwellcollins.spear.UnaryExpr;
import com.rockwellcollins.spear.UserType;
import com.rockwellcollins.spear.Variable;
import com.rockwellcollins.spear.WhileExpr;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SpearSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SpearGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SpearPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SpearPackage.AFTER_UNTIL_EXPR:
				sequence_AtomicExpr(context, (AfterUntilExpr) semanticObject); 
				return; 
			case SpearPackage.ARRAY_ACCESS_EXPR:
				sequence_AccessExpr(context, (ArrayAccessExpr) semanticObject); 
				return; 
			case SpearPackage.ARRAY_EXPR:
				sequence_AtomicExpr(context, (ArrayExpr) semanticObject); 
				return; 
			case SpearPackage.ARRAY_TYPE_DEF:
				sequence_TypeDef(context, (ArrayTypeDef) semanticObject); 
				return; 
			case SpearPackage.ARRAY_UPDATE_EXPR:
				sequence_AccessExpr(context, (ArrayUpdateExpr) semanticObject); 
				return; 
			case SpearPackage.BASE_UNIT:
				sequence_UnitDef(context, (BaseUnit) semanticObject); 
				return; 
			case SpearPackage.BINARY_EXPR:
				sequence_AndExpr_ImpliesExpr_MultiplyExpr_OrExpr_PlusExpr_RelationalExpr_SinceExpr_TriggersExpr(context, (BinaryExpr) semanticObject); 
				return; 
			case SpearPackage.BINARY_UNIT_EXPR:
				sequence_DivisionUnitExpr_ProductUnitExpr(context, (BinaryUnitExpr) semanticObject); 
				return; 
			case SpearPackage.BOOL_LITERAL:
				sequence_LiteralExpr(context, (BoolLiteral) semanticObject); 
				return; 
			case SpearPackage.BOOL_TYPE:
				sequence_Type(context, (BoolType) semanticObject); 
				return; 
			case SpearPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case SpearPackage.DEFINITIONS:
				sequence_Definitions(context, (Definitions) semanticObject); 
				return; 
			case SpearPackage.DERIVED_UNIT:
				sequence_UnitDef(context, (DerivedUnit) semanticObject); 
				return; 
			case SpearPackage.ENGLISH_CONSTRAINT:
				sequence_EnglishConstraint(context, (EnglishConstraint) semanticObject); 
				return; 
			case SpearPackage.ENUM_TYPE_DEF:
				sequence_TypeDef(context, (EnumTypeDef) semanticObject); 
				return; 
			case SpearPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case SpearPackage.FIELD_EXPR:
				sequence_FieldExpr(context, (FieldExpr) semanticObject); 
				return; 
			case SpearPackage.FIELD_TYPE:
				sequence_FieldType(context, (FieldType) semanticObject); 
				return; 
			case SpearPackage.FIELDLESS_RECORD_EXPR:
				sequence_AtomicExpr(context, (FieldlessRecordExpr) semanticObject); 
				return; 
			case SpearPackage.FORMAL_CONSTRAINT:
				sequence_FormalConstraint(context, (FormalConstraint) semanticObject); 
				return; 
			case SpearPackage.ID_EXPR:
				sequence_AtomicExpr(context, (IdExpr) semanticObject); 
				return; 
			case SpearPackage.IF_THEN_ELSE_EXPR:
				sequence_AtomicExpr(context, (IfThenElseExpr) semanticObject); 
				return; 
			case SpearPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SpearPackage.INT_LITERAL:
				sequence_LiteralExpr(context, (IntLiteral) semanticObject); 
				return; 
			case SpearPackage.INT_TYPE:
				sequence_Type(context, (IntType) semanticObject); 
				return; 
			case SpearPackage.LUSTRE_EQUATION:
				sequence_LustreEquation(context, (LustreEquation) semanticObject); 
				return; 
			case SpearPackage.MID_EXPR:
				sequence_AtomicExpr(context, (MIdExpr) semanticObject); 
				return; 
			case SpearPackage.MACRO:
				sequence_Macro(context, (Macro) semanticObject); 
				return; 
			case SpearPackage.NAMED_TYPE_DEF:
				sequence_TypeDef(context, (NamedTypeDef) semanticObject); 
				return; 
			case SpearPackage.NAMED_UNIT_EXPR:
				sequence_AtomicUnitExpr(context, (NamedUnitExpr) semanticObject); 
				return; 
			case SpearPackage.NORMALIZED_CALL:
				sequence_UnusedExpr(context, (NormalizedCall) semanticObject); 
				return; 
			case SpearPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case SpearPackage.PATTERN_CALL:
				sequence_AtomicExpr(context, (PatternCall) semanticObject); 
				return; 
			case SpearPackage.PREVIOUS_EXPR:
				sequence_PrefixExpr(context, (PreviousExpr) semanticObject); 
				return; 
			case SpearPackage.REAL_LITERAL:
				sequence_LiteralExpr(context, (RealLiteral) semanticObject); 
				return; 
			case SpearPackage.REAL_TYPE:
				sequence_Type(context, (RealType) semanticObject); 
				return; 
			case SpearPackage.RECORD_ACCESS_EXPR:
				sequence_AccessExpr(context, (RecordAccessExpr) semanticObject); 
				return; 
			case SpearPackage.RECORD_EXPR:
				sequence_AtomicExpr(context, (RecordExpr) semanticObject); 
				return; 
			case SpearPackage.RECORD_TYPE_DEF:
				sequence_TypeDef(context, (RecordTypeDef) semanticObject); 
				return; 
			case SpearPackage.RECORD_UPDATE_EXPR:
				sequence_AccessExpr(context, (RecordUpdateExpr) semanticObject); 
				return; 
			case SpearPackage.SPECIFICATION:
				sequence_Specification(context, (Specification) semanticObject); 
				return; 
			case SpearPackage.SPECIFICATION_CALL:
				sequence_AtomicExpr(context, (SpecificationCall) semanticObject); 
				return; 
			case SpearPackage.UNARY_EXPR:
				sequence_PrefixExpr_TemporalPrefixExpr(context, (UnaryExpr) semanticObject); 
				return; 
			case SpearPackage.USER_TYPE:
				sequence_Type(context, (UserType) semanticObject); 
				return; 
			case SpearPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case SpearPackage.WHILE_EXPR:
				sequence_AtomicExpr(context, (WhileExpr) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expr returns ArrayAccessExpr
	 *     ImpliesExpr returns ArrayAccessExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     OrExpr returns ArrayAccessExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     AndExpr returns ArrayAccessExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     TriggersExpr returns ArrayAccessExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     SinceExpr returns ArrayAccessExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     TemporalPrefixExpr returns ArrayAccessExpr
	 *     RelationalExpr returns ArrayAccessExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     PlusExpr returns ArrayAccessExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     MultiplyExpr returns ArrayAccessExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     PrefixExpr returns ArrayAccessExpr
	 *     AccessExpr returns ArrayAccessExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns ArrayAccessExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns ArrayAccessExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns ArrayAccessExpr
	 *     AccessExpr.ArrayUpdateExpr_1_2_2_0_0_0 returns ArrayAccessExpr
	 *     AtomicExpr returns ArrayAccessExpr
	 *
	 * Constraint:
	 *     (array=AccessExpr_ArrayAccessExpr_1_2_0_0_0 index=Expr)
	 */
	protected void sequence_AccessExpr(ISerializationContext context, ArrayAccessExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.ARRAY_ACCESS_EXPR__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.ARRAY_ACCESS_EXPR__ARRAY));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.ARRAY_ACCESS_EXPR__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.ARRAY_ACCESS_EXPR__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessExprAccess().getArrayAccessExprArrayAction_1_2_0_0_0(), semanticObject.getArray());
		feeder.accept(grammarAccess.getAccessExprAccess().getIndexExprParserRuleCall_1_2_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns ArrayUpdateExpr
	 *     ImpliesExpr returns ArrayUpdateExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     OrExpr returns ArrayUpdateExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     AndExpr returns ArrayUpdateExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     TriggersExpr returns ArrayUpdateExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     SinceExpr returns ArrayUpdateExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     TemporalPrefixExpr returns ArrayUpdateExpr
	 *     RelationalExpr returns ArrayUpdateExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     PlusExpr returns ArrayUpdateExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     MultiplyExpr returns ArrayUpdateExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     PrefixExpr returns ArrayUpdateExpr
	 *     AccessExpr returns ArrayUpdateExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns ArrayUpdateExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns ArrayUpdateExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns ArrayUpdateExpr
	 *     AtomicExpr returns ArrayUpdateExpr
	 *
	 * Constraint:
	 *     (access=AccessExpr_ArrayUpdateExpr_1_2_2_0_0_0 value=Expr)
	 */
	protected void sequence_AccessExpr(ISerializationContext context, ArrayUpdateExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.ARRAY_UPDATE_EXPR__ACCESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.ARRAY_UPDATE_EXPR__ACCESS));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.ARRAY_UPDATE_EXPR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.ARRAY_UPDATE_EXPR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessExprAccess().getArrayUpdateExprAccessAction_1_2_2_0_0_0(), semanticObject.getAccess());
		feeder.accept(grammarAccess.getAccessExprAccess().getValueExprParserRuleCall_1_2_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns RecordAccessExpr
	 *     ImpliesExpr returns RecordAccessExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     OrExpr returns RecordAccessExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     AndExpr returns RecordAccessExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     TriggersExpr returns RecordAccessExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     SinceExpr returns RecordAccessExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     TemporalPrefixExpr returns RecordAccessExpr
	 *     RelationalExpr returns RecordAccessExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     PlusExpr returns RecordAccessExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     MultiplyExpr returns RecordAccessExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     PrefixExpr returns RecordAccessExpr
	 *     AccessExpr returns RecordAccessExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns RecordAccessExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns RecordAccessExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns RecordAccessExpr
	 *     AtomicExpr returns RecordAccessExpr
	 *
	 * Constraint:
	 *     (record=AccessExpr_RecordAccessExpr_1_0_0_0_0 field=[FieldType|ID])
	 */
	protected void sequence_AccessExpr(ISerializationContext context, RecordAccessExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.RECORD_ACCESS_EXPR__RECORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.RECORD_ACCESS_EXPR__RECORD));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.RECORD_ACCESS_EXPR__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.RECORD_ACCESS_EXPR__FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessExprAccess().getRecordAccessExprRecordAction_1_0_0_0_0(), semanticObject.getRecord());
		feeder.accept(grammarAccess.getAccessExprAccess().getFieldFieldTypeIDTerminalRuleCall_1_0_1_0_1(), semanticObject.getField());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns RecordUpdateExpr
	 *     ImpliesExpr returns RecordUpdateExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     OrExpr returns RecordUpdateExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     AndExpr returns RecordUpdateExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     TriggersExpr returns RecordUpdateExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     SinceExpr returns RecordUpdateExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     TemporalPrefixExpr returns RecordUpdateExpr
	 *     RelationalExpr returns RecordUpdateExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     PlusExpr returns RecordUpdateExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     MultiplyExpr returns RecordUpdateExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     PrefixExpr returns RecordUpdateExpr
	 *     AccessExpr returns RecordUpdateExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns RecordUpdateExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns RecordUpdateExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns RecordUpdateExpr
	 *     AtomicExpr returns RecordUpdateExpr
	 *
	 * Constraint:
	 *     (record=AccessExpr_RecordUpdateExpr_1_1_0_0_0 field=[FieldType|ID] value=Expr)
	 */
	protected void sequence_AccessExpr(ISerializationContext context, RecordUpdateExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.RECORD_UPDATE_EXPR__RECORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.RECORD_UPDATE_EXPR__RECORD));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.RECORD_UPDATE_EXPR__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.RECORD_UPDATE_EXPR__FIELD));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.RECORD_UPDATE_EXPR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.RECORD_UPDATE_EXPR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessExprAccess().getRecordUpdateExprRecordAction_1_1_0_0_0(), semanticObject.getRecord());
		feeder.accept(grammarAccess.getAccessExprAccess().getFieldFieldTypeIDTerminalRuleCall_1_1_0_0_2_0_1(), semanticObject.getField());
		feeder.accept(grammarAccess.getAccessExprAccess().getValueExprParserRuleCall_1_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns BinaryExpr
	 *     ImpliesExpr returns BinaryExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     OrExpr returns BinaryExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     AndExpr returns BinaryExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     TriggersExpr returns BinaryExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     SinceExpr returns BinaryExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     TemporalPrefixExpr returns BinaryExpr
	 *     RelationalExpr returns BinaryExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     PlusExpr returns BinaryExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     MultiplyExpr returns BinaryExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     PrefixExpr returns BinaryExpr
	 *     AccessExpr returns BinaryExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns BinaryExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns BinaryExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns BinaryExpr
	 *     AtomicExpr returns BinaryExpr
	 *
	 * Constraint:
	 *     (
	 *         (left=ImpliesExpr_BinaryExpr_1_0_0_0 (op='=>' | op='implies') right=ImpliesExpr) | 
	 *         (left=OrExpr_BinaryExpr_1_0_0_0 (op='or' | op='xor') right=ImpliesExpr) | 
	 *         (left=AndExpr_BinaryExpr_1_0_0_0 op='and' right=AndExpr) | 
	 *         (left=TriggersExpr_BinaryExpr_1_0_0_0 (op='T' | op='triggers') right=TriggersExpr) | 
	 *         (left=SinceExpr_BinaryExpr_1_0_0_0 (op='S' | op='since') right=SinceExpr) | 
	 *         (left=RelationalExpr_BinaryExpr_1_0_0_0 op=RelationalOp right=RelationalExpr) | 
	 *         (left=PlusExpr_BinaryExpr_1_0_0_0 (op='+' | op='-') right=PlusExpr) | 
	 *         (left=MultiplyExpr_BinaryExpr_1_0_0_0 (op='*' | op='/' | op='mod') right=MultiplyExpr)
	 *     )
	 */
	protected void sequence_AndExpr_ImpliesExpr_MultiplyExpr_OrExpr_PlusExpr_RelationalExpr_SinceExpr_TriggersExpr(ISerializationContext context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns AfterUntilExpr
	 *     ImpliesExpr returns AfterUntilExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns AfterUntilExpr
	 *     OrExpr returns AfterUntilExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns AfterUntilExpr
	 *     AndExpr returns AfterUntilExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns AfterUntilExpr
	 *     TriggersExpr returns AfterUntilExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns AfterUntilExpr
	 *     SinceExpr returns AfterUntilExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns AfterUntilExpr
	 *     TemporalPrefixExpr returns AfterUntilExpr
	 *     RelationalExpr returns AfterUntilExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns AfterUntilExpr
	 *     PlusExpr returns AfterUntilExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns AfterUntilExpr
	 *     MultiplyExpr returns AfterUntilExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns AfterUntilExpr
	 *     PrefixExpr returns AfterUntilExpr
	 *     AccessExpr returns AfterUntilExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns AfterUntilExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns AfterUntilExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns AfterUntilExpr
	 *     AtomicExpr returns AfterUntilExpr
	 *
	 * Constraint:
	 *     (after=Expr until=Expr?)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, AfterUntilExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns ArrayExpr
	 *     ImpliesExpr returns ArrayExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     OrExpr returns ArrayExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     AndExpr returns ArrayExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     TriggersExpr returns ArrayExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     SinceExpr returns ArrayExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     TemporalPrefixExpr returns ArrayExpr
	 *     RelationalExpr returns ArrayExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     PlusExpr returns ArrayExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     MultiplyExpr returns ArrayExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     PrefixExpr returns ArrayExpr
	 *     AccessExpr returns ArrayExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns ArrayExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns ArrayExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns ArrayExpr
	 *     AtomicExpr returns ArrayExpr
	 *
	 * Constraint:
	 *     (type=[ArrayTypeDef|ID] exprs+=Expr exprs+=Expr*)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, ArrayExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns FieldlessRecordExpr
	 *     ImpliesExpr returns FieldlessRecordExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns FieldlessRecordExpr
	 *     OrExpr returns FieldlessRecordExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns FieldlessRecordExpr
	 *     AndExpr returns FieldlessRecordExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns FieldlessRecordExpr
	 *     TriggersExpr returns FieldlessRecordExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns FieldlessRecordExpr
	 *     SinceExpr returns FieldlessRecordExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns FieldlessRecordExpr
	 *     TemporalPrefixExpr returns FieldlessRecordExpr
	 *     RelationalExpr returns FieldlessRecordExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns FieldlessRecordExpr
	 *     PlusExpr returns FieldlessRecordExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns FieldlessRecordExpr
	 *     MultiplyExpr returns FieldlessRecordExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns FieldlessRecordExpr
	 *     PrefixExpr returns FieldlessRecordExpr
	 *     AccessExpr returns FieldlessRecordExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns FieldlessRecordExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns FieldlessRecordExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns FieldlessRecordExpr
	 *     AtomicExpr returns FieldlessRecordExpr
	 *
	 * Constraint:
	 *     (type=[RecordTypeDef|ID] exprs+=Expr exprs+=Expr*)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, FieldlessRecordExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns IdExpr
	 *     ImpliesExpr returns IdExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     OrExpr returns IdExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     AndExpr returns IdExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     TriggersExpr returns IdExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     SinceExpr returns IdExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     TemporalPrefixExpr returns IdExpr
	 *     RelationalExpr returns IdExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     PlusExpr returns IdExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     MultiplyExpr returns IdExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     PrefixExpr returns IdExpr
	 *     AccessExpr returns IdExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns IdExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns IdExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns IdExpr
	 *     AtomicExpr returns IdExpr
	 *
	 * Constraint:
	 *     id=[IdRef|ID]
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, IdExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.ID_EXPR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.ID_EXPR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExprAccess().getIdIdRefIDTerminalRuleCall_1_1_0_1(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns IfThenElseExpr
	 *     ImpliesExpr returns IfThenElseExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     OrExpr returns IfThenElseExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     AndExpr returns IfThenElseExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     TriggersExpr returns IfThenElseExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     SinceExpr returns IfThenElseExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     TemporalPrefixExpr returns IfThenElseExpr
	 *     RelationalExpr returns IfThenElseExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     PlusExpr returns IfThenElseExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     MultiplyExpr returns IfThenElseExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     PrefixExpr returns IfThenElseExpr
	 *     AccessExpr returns IfThenElseExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns IfThenElseExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns IfThenElseExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns IfThenElseExpr
	 *     AtomicExpr returns IfThenElseExpr
	 *
	 * Constraint:
	 *     (cond=Expr then=Expr else=Expr?)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, IfThenElseExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns MIdExpr
	 *     ImpliesExpr returns MIdExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns MIdExpr
	 *     OrExpr returns MIdExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns MIdExpr
	 *     AndExpr returns MIdExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns MIdExpr
	 *     TriggersExpr returns MIdExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns MIdExpr
	 *     SinceExpr returns MIdExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns MIdExpr
	 *     TemporalPrefixExpr returns MIdExpr
	 *     RelationalExpr returns MIdExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns MIdExpr
	 *     PlusExpr returns MIdExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns MIdExpr
	 *     MultiplyExpr returns MIdExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns MIdExpr
	 *     PrefixExpr returns MIdExpr
	 *     AccessExpr returns MIdExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns MIdExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns MIdExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns MIdExpr
	 *     AtomicExpr returns MIdExpr
	 *
	 * Constraint:
	 *     (ids+=[IdRef|ID] ids+=[IdRef|ID]*)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, MIdExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns PatternCall
	 *     ImpliesExpr returns PatternCall
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns PatternCall
	 *     OrExpr returns PatternCall
	 *     OrExpr.BinaryExpr_1_0_0_0 returns PatternCall
	 *     AndExpr returns PatternCall
	 *     AndExpr.BinaryExpr_1_0_0_0 returns PatternCall
	 *     TriggersExpr returns PatternCall
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns PatternCall
	 *     SinceExpr returns PatternCall
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns PatternCall
	 *     TemporalPrefixExpr returns PatternCall
	 *     RelationalExpr returns PatternCall
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns PatternCall
	 *     PlusExpr returns PatternCall
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns PatternCall
	 *     MultiplyExpr returns PatternCall
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns PatternCall
	 *     PrefixExpr returns PatternCall
	 *     AccessExpr returns PatternCall
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns PatternCall
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns PatternCall
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns PatternCall
	 *     AtomicExpr returns PatternCall
	 *
	 * Constraint:
	 *     (pattern=[Pattern|ID] args+=Expr args+=Expr*)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, PatternCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns RecordExpr
	 *     ImpliesExpr returns RecordExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     OrExpr returns RecordExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     AndExpr returns RecordExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     TriggersExpr returns RecordExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     SinceExpr returns RecordExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     TemporalPrefixExpr returns RecordExpr
	 *     RelationalExpr returns RecordExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     PlusExpr returns RecordExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     MultiplyExpr returns RecordExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     PrefixExpr returns RecordExpr
	 *     AccessExpr returns RecordExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns RecordExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns RecordExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns RecordExpr
	 *     AtomicExpr returns RecordExpr
	 *
	 * Constraint:
	 *     (type=[RecordTypeDef|ID] fieldExprs+=FieldExpr fieldExprs+=FieldExpr*)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, RecordExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns SpecificationCall
	 *     ImpliesExpr returns SpecificationCall
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns SpecificationCall
	 *     OrExpr returns SpecificationCall
	 *     OrExpr.BinaryExpr_1_0_0_0 returns SpecificationCall
	 *     AndExpr returns SpecificationCall
	 *     AndExpr.BinaryExpr_1_0_0_0 returns SpecificationCall
	 *     TriggersExpr returns SpecificationCall
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns SpecificationCall
	 *     SinceExpr returns SpecificationCall
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns SpecificationCall
	 *     TemporalPrefixExpr returns SpecificationCall
	 *     RelationalExpr returns SpecificationCall
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns SpecificationCall
	 *     PlusExpr returns SpecificationCall
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns SpecificationCall
	 *     MultiplyExpr returns SpecificationCall
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns SpecificationCall
	 *     PrefixExpr returns SpecificationCall
	 *     AccessExpr returns SpecificationCall
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns SpecificationCall
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns SpecificationCall
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns SpecificationCall
	 *     AtomicExpr returns SpecificationCall
	 *
	 * Constraint:
	 *     (spec=[Specification|ID] args+=Expr args+=Expr*)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, SpecificationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns WhileExpr
	 *     ImpliesExpr returns WhileExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns WhileExpr
	 *     OrExpr returns WhileExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns WhileExpr
	 *     AndExpr returns WhileExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns WhileExpr
	 *     TriggersExpr returns WhileExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns WhileExpr
	 *     SinceExpr returns WhileExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns WhileExpr
	 *     TemporalPrefixExpr returns WhileExpr
	 *     RelationalExpr returns WhileExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns WhileExpr
	 *     PlusExpr returns WhileExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns WhileExpr
	 *     MultiplyExpr returns WhileExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns WhileExpr
	 *     PrefixExpr returns WhileExpr
	 *     AccessExpr returns WhileExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns WhileExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns WhileExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns WhileExpr
	 *     AtomicExpr returns WhileExpr
	 *
	 * Constraint:
	 *     (cond=Expr then=Expr)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, WhileExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.WHILE_EXPR__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.WHILE_EXPR__COND));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.WHILE_EXPR__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.WHILE_EXPR__THEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExprAccess().getCondExprParserRuleCall_5_2_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getAtomicExprAccess().getThenExprParserRuleCall_5_4_0(), semanticObject.getThen());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnitExpr returns NamedUnitExpr
	 *     ProductUnitExpr returns NamedUnitExpr
	 *     ProductUnitExpr.BinaryUnitExpr_1_0_0_0 returns NamedUnitExpr
	 *     DivisionUnitExpr returns NamedUnitExpr
	 *     DivisionUnitExpr.BinaryUnitExpr_1_0_0_0 returns NamedUnitExpr
	 *     AtomicUnitExpr returns NamedUnitExpr
	 *
	 * Constraint:
	 *     unit=[UnitDef|ID]
	 */
	protected void sequence_AtomicUnitExpr(ISerializationContext context, NamedUnitExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.NAMED_UNIT_EXPR__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.NAMED_UNIT_EXPR__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicUnitExprAccess().getUnitUnitDefIDTerminalRuleCall_0_1_0_1(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns Constant
	 *     IdRef returns Constant
	 *
	 * Constraint:
	 *     (name=ID type=Type expr=Expr descriptor=STRING?)
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     File returns Definitions
	 *     Definitions returns Definitions
	 *
	 * Constraint:
	 *     (name=ID unitdefs+=UnitDef* typedefs+=TypeDef* constants+=Constant* patterns+=Pattern*)
	 */
	protected void sequence_Definitions(ISerializationContext context, Definitions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitExpr returns BinaryUnitExpr
	 *     ProductUnitExpr returns BinaryUnitExpr
	 *     ProductUnitExpr.BinaryUnitExpr_1_0_0_0 returns BinaryUnitExpr
	 *     DivisionUnitExpr returns BinaryUnitExpr
	 *     DivisionUnitExpr.BinaryUnitExpr_1_0_0_0 returns BinaryUnitExpr
	 *     AtomicUnitExpr returns BinaryUnitExpr
	 *
	 * Constraint:
	 *     (
	 *         (left=ProductUnitExpr_BinaryUnitExpr_1_0_0_0 op='*' right=ProductUnitExpr) | 
	 *         (left=DivisionUnitExpr_BinaryUnitExpr_1_0_0_0 op='/' right=AtomicUnitExpr)
	 *     )
	 */
	protected void sequence_DivisionUnitExpr_ProductUnitExpr(ISerializationContext context, BinaryUnitExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns EnglishConstraint
	 *     EnglishConstraint returns EnglishConstraint
	 *
	 * Constraint:
	 *     (name=ID text=STRING)
	 */
	protected void sequence_EnglishConstraint(ISerializationContext context, EnglishConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.CONSTRAINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.CONSTRAINT__NAME));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.ENGLISH_CONSTRAINT__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.ENGLISH_CONSTRAINT__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnglishConstraintAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEnglishConstraintAccess().getTextSTRINGTerminalRuleCall_2_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnumValue returns EnumValue
	 *     IdRef returns EnumValue
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumValue(ISerializationContext context, EnumValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.ID_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.ID_REF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumValueAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FieldExpr returns FieldExpr
	 *
	 * Constraint:
	 *     (field=[FieldType|ID] expr=Expr)
	 */
	protected void sequence_FieldExpr(ISerializationContext context, FieldExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.FIELD_EXPR__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.FIELD_EXPR__FIELD));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.FIELD_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.FIELD_EXPR__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldExprAccess().getFieldFieldTypeIDTerminalRuleCall_0_0_1(), semanticObject.getField());
		feeder.accept(grammarAccess.getFieldExprAccess().getExprExprParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FieldType returns FieldType
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_FieldType(ISerializationContext context, FieldType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.FIELD_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.FIELD_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.FIELD_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.FIELD_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldTypeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldTypeAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns FormalConstraint
	 *     FormalConstraint returns FormalConstraint
	 *
	 * Constraint:
	 *     (name=ID expr=Expr descriptor=STRING?)
	 */
	protected void sequence_FormalConstraint(ISerializationContext context, FormalConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns BoolLiteral
	 *     ImpliesExpr returns BoolLiteral
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns BoolLiteral
	 *     OrExpr returns BoolLiteral
	 *     OrExpr.BinaryExpr_1_0_0_0 returns BoolLiteral
	 *     AndExpr returns BoolLiteral
	 *     AndExpr.BinaryExpr_1_0_0_0 returns BoolLiteral
	 *     TriggersExpr returns BoolLiteral
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns BoolLiteral
	 *     SinceExpr returns BoolLiteral
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns BoolLiteral
	 *     TemporalPrefixExpr returns BoolLiteral
	 *     RelationalExpr returns BoolLiteral
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns BoolLiteral
	 *     PlusExpr returns BoolLiteral
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns BoolLiteral
	 *     MultiplyExpr returns BoolLiteral
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns BoolLiteral
	 *     PrefixExpr returns BoolLiteral
	 *     AccessExpr returns BoolLiteral
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns BoolLiteral
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns BoolLiteral
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns BoolLiteral
	 *     AtomicExpr returns BoolLiteral
	 *     LiteralExpr returns BoolLiteral
	 *
	 * Constraint:
	 *     value=BOOL
	 */
	protected void sequence_LiteralExpr(ISerializationContext context, BoolLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.BOOL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.BOOL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExprAccess().getValueBOOLParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns IntLiteral
	 *     ImpliesExpr returns IntLiteral
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns IntLiteral
	 *     OrExpr returns IntLiteral
	 *     OrExpr.BinaryExpr_1_0_0_0 returns IntLiteral
	 *     AndExpr returns IntLiteral
	 *     AndExpr.BinaryExpr_1_0_0_0 returns IntLiteral
	 *     TriggersExpr returns IntLiteral
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns IntLiteral
	 *     SinceExpr returns IntLiteral
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns IntLiteral
	 *     TemporalPrefixExpr returns IntLiteral
	 *     RelationalExpr returns IntLiteral
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns IntLiteral
	 *     PlusExpr returns IntLiteral
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns IntLiteral
	 *     MultiplyExpr returns IntLiteral
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns IntLiteral
	 *     PrefixExpr returns IntLiteral
	 *     AccessExpr returns IntLiteral
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns IntLiteral
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns IntLiteral
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns IntLiteral
	 *     AtomicExpr returns IntLiteral
	 *     LiteralExpr returns IntLiteral
	 *
	 * Constraint:
	 *     (value=INT unit=[UnitDef|ID]?)
	 */
	protected void sequence_LiteralExpr(ISerializationContext context, IntLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns RealLiteral
	 *     ImpliesExpr returns RealLiteral
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns RealLiteral
	 *     OrExpr returns RealLiteral
	 *     OrExpr.BinaryExpr_1_0_0_0 returns RealLiteral
	 *     AndExpr returns RealLiteral
	 *     AndExpr.BinaryExpr_1_0_0_0 returns RealLiteral
	 *     TriggersExpr returns RealLiteral
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns RealLiteral
	 *     SinceExpr returns RealLiteral
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns RealLiteral
	 *     TemporalPrefixExpr returns RealLiteral
	 *     RelationalExpr returns RealLiteral
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns RealLiteral
	 *     PlusExpr returns RealLiteral
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns RealLiteral
	 *     MultiplyExpr returns RealLiteral
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns RealLiteral
	 *     PrefixExpr returns RealLiteral
	 *     AccessExpr returns RealLiteral
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns RealLiteral
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns RealLiteral
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns RealLiteral
	 *     AtomicExpr returns RealLiteral
	 *     LiteralExpr returns RealLiteral
	 *
	 * Constraint:
	 *     (value=REAL unit=[UnitDef|ID]?)
	 */
	protected void sequence_LiteralExpr(ISerializationContext context, RealLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LustreEquation returns LustreEquation
	 *
	 * Constraint:
	 *     (id=[Variable|ID] rhs=Expr)
	 */
	protected void sequence_LustreEquation(ISerializationContext context, LustreEquation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.LUSTRE_EQUATION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.LUSTRE_EQUATION__ID));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.LUSTRE_EQUATION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.LUSTRE_EQUATION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLustreEquationAccess().getIdVariableIDTerminalRuleCall_0_0_1(), semanticObject.getId());
		feeder.accept(grammarAccess.getLustreEquationAccess().getRhsExprParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Macro returns Macro
	 *     IdRef returns Macro
	 *
	 * Constraint:
	 *     (name=ID type=Type expr=Expr descriptor=STRING?)
	 */
	protected void sequence_Macro(ISerializationContext context, Macro semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         inputs+=Variable 
	 *         inputs+=Variable* 
	 *         outputs+=Variable 
	 *         outputs+=Variable* 
	 *         locals+=Variable* 
	 *         equations+=LustreEquation*
	 *     )
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns PreviousExpr
	 *     ImpliesExpr returns PreviousExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns PreviousExpr
	 *     OrExpr returns PreviousExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns PreviousExpr
	 *     AndExpr returns PreviousExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns PreviousExpr
	 *     TriggersExpr returns PreviousExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns PreviousExpr
	 *     SinceExpr returns PreviousExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns PreviousExpr
	 *     TemporalPrefixExpr returns PreviousExpr
	 *     RelationalExpr returns PreviousExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns PreviousExpr
	 *     PlusExpr returns PreviousExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns PreviousExpr
	 *     MultiplyExpr returns PreviousExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns PreviousExpr
	 *     PrefixExpr returns PreviousExpr
	 *     AccessExpr returns PreviousExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns PreviousExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns PreviousExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns PreviousExpr
	 *     AtomicExpr returns PreviousExpr
	 *
	 * Constraint:
	 *     (var=PrefixExpr init=PrefixExpr?)
	 */
	protected void sequence_PrefixExpr(ISerializationContext context, PreviousExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns UnaryExpr
	 *     ImpliesExpr returns UnaryExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     OrExpr returns UnaryExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     AndExpr returns UnaryExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     TriggersExpr returns UnaryExpr
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     SinceExpr returns UnaryExpr
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     TemporalPrefixExpr returns UnaryExpr
	 *     RelationalExpr returns UnaryExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     PlusExpr returns UnaryExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     MultiplyExpr returns UnaryExpr
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     PrefixExpr returns UnaryExpr
	 *     AccessExpr returns UnaryExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns UnaryExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns UnaryExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns UnaryExpr
	 *     AtomicExpr returns UnaryExpr
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 op='O' | 
	 *                 op='once' | 
	 *                 op='H' | 
	 *                 op='historically' | 
	 *                 op='never' | 
	 *                 op='before' | 
	 *                 op='initially'
	 *             ) 
	 *             expr=TemporalPrefixExpr
	 *         ) | 
	 *         ((op='-' | op='not') expr=PrefixExpr)
	 *     )
	 */
	protected void sequence_PrefixExpr_TemporalPrefixExpr(ISerializationContext context, UnaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     File returns Specification
	 *     Specification returns Specification
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         imports+=Import* 
	 *         units+=UnitDef* 
	 *         typedefs+=TypeDef* 
	 *         constants+=Constant* 
	 *         patterns+=Pattern* 
	 *         inputs+=Variable* 
	 *         outputs+=Variable* 
	 *         state+=Variable* 
	 *         macros+=Macro* 
	 *         assumptions+=Constraint* 
	 *         requirements+=Constraint* 
	 *         behaviors+=Constraint*
	 *     )
	 */
	protected void sequence_Specification(ISerializationContext context, Specification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDef returns ArrayTypeDef
	 *
	 * Constraint:
	 *     (name=ID base=Type size=INT)
	 */
	protected void sequence_TypeDef(ISerializationContext context, ArrayTypeDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.TYPE_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.TYPE_DEF__NAME));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.ARRAY_TYPE_DEF__BASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.ARRAY_TYPE_DEF__BASE));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.ARRAY_TYPE_DEF__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.ARRAY_TYPE_DEF__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeDefAccess().getNameIDTerminalRuleCall_2_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypeDefAccess().getBaseTypeParserRuleCall_2_3_0(), semanticObject.getBase());
		feeder.accept(grammarAccess.getTypeDefAccess().getSizeINTTerminalRuleCall_2_5_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeDef returns EnumTypeDef
	 *
	 * Constraint:
	 *     (name=ID values+=EnumValue values+=EnumValue*)
	 */
	protected void sequence_TypeDef(ISerializationContext context, EnumTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDef returns NamedTypeDef
	 *
	 * Constraint:
	 *     (name=ID type=Type unit=[UnitDef|ID]?)
	 */
	protected void sequence_TypeDef(ISerializationContext context, NamedTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDef returns RecordTypeDef
	 *
	 * Constraint:
	 *     (name=ID fields+=FieldType fields+=FieldType*)
	 */
	protected void sequence_TypeDef(ISerializationContext context, RecordTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns BoolType
	 *
	 * Constraint:
	 *     {BoolType}
	 */
	protected void sequence_Type(ISerializationContext context, BoolType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns IntType
	 *
	 * Constraint:
	 *     {IntType}
	 */
	protected void sequence_Type(ISerializationContext context, IntType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns RealType
	 *
	 * Constraint:
	 *     {RealType}
	 */
	protected void sequence_Type(ISerializationContext context, RealType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns UserType
	 *
	 * Constraint:
	 *     def=[TypeDef|ID]
	 */
	protected void sequence_Type(ISerializationContext context, UserType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.USER_TYPE__DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.USER_TYPE__DEF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getDefTypeDefIDTerminalRuleCall_3_1_0_1(), semanticObject.getDef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnitDef returns BaseUnit
	 *
	 * Constraint:
	 *     (name=ID description=STRING?)
	 */
	protected void sequence_UnitDef(ISerializationContext context, BaseUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitDef returns DerivedUnit
	 *
	 * Constraint:
	 *     (name=ID unit=UnitExpr description=STRING?)
	 */
	protected void sequence_UnitDef(ISerializationContext context, DerivedUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns NormalizedCall
	 *     ImpliesExpr returns NormalizedCall
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns NormalizedCall
	 *     OrExpr returns NormalizedCall
	 *     OrExpr.BinaryExpr_1_0_0_0 returns NormalizedCall
	 *     AndExpr returns NormalizedCall
	 *     AndExpr.BinaryExpr_1_0_0_0 returns NormalizedCall
	 *     TriggersExpr returns NormalizedCall
	 *     TriggersExpr.BinaryExpr_1_0_0_0 returns NormalizedCall
	 *     SinceExpr returns NormalizedCall
	 *     SinceExpr.BinaryExpr_1_0_0_0 returns NormalizedCall
	 *     TemporalPrefixExpr returns NormalizedCall
	 *     RelationalExpr returns NormalizedCall
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns NormalizedCall
	 *     PlusExpr returns NormalizedCall
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns NormalizedCall
	 *     MultiplyExpr returns NormalizedCall
	 *     MultiplyExpr.BinaryExpr_1_0_0_0 returns NormalizedCall
	 *     PrefixExpr returns NormalizedCall
	 *     AccessExpr returns NormalizedCall
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns NormalizedCall
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns NormalizedCall
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns NormalizedCall
	 *     AtomicExpr returns NormalizedCall
	 *     UnusedExpr returns NormalizedCall
	 *
	 * Constraint:
	 *     (ids+=[IdRef|ID] ids+=[IdRef|ID]* spec=[Specification|ID] args+=Expr args+=Expr*)
	 */
	protected void sequence_UnusedExpr(ISerializationContext context, NormalizedCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *     IdRef returns Variable
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.ID_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.ID_REF__NAME));
			if (transientValues.isValueTransient(semanticObject, SpearPackage.Literals.VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpearPackage.Literals.VARIABLE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
}
