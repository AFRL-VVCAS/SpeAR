/*
 * generated by Xtext
 */
package com.rockwellcollins.spear.ui.commandline;

import java.nio.file.Paths;
import java.nio.file.Path;
import java.io.IOException;
import java.nio.file.Files;
import java.util.List;
import java.util.stream.Collectors;

import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;

import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Provider;
import com.rockwellcollins.spear.Definitions;
import com.rockwellcollins.spear.File;
import com.rockwellcollins.spear.Specification;
import com.rockwellcollins.spear.preferences.PreferencesUtil;
import com.rockwellcollins.spear.translate.intermediate.SpearDocument;
import com.rockwellcollins.spear.translate.master.SProgram;
import com.rockwellcollins.spear.typing.SpearTypeChecker;
import com.rockwellcollins.spear.units.SpearUnitChecker;

import jkind.api.JKindApi;
import jkind.api.results.JKindResult;
import jkind.api.results.MapRenaming;
import jkind.api.results.Renaming;
import jkind.api.results.MapRenaming.Mode;
import jkind.lustre.Program;

public class Main {

  public static void main(String[] args) {

    Injector injector = new com.rockwellcollins.SpearStandaloneSetup().createInjectorAndDoEMFRegistration();
    Main main = injector.getInstance(Main.class);
    Arguments pargs = Arguments.parse(args);
    main.runGenerator(pargs);
  }

  @Inject
  private Provider<ResourceSet> resourceSetProvider;

  @Inject
  private IResourceValidator    validator;

  private void processSpecification(Arguments args, String file) {
    // XXX: If an absolute path is not used calls to Utilities.getImportedFile may fail.
    ResourceSet set = resourceSetProvider.get();
    if (!Paths.get(file).isAbsolute()) {
      file = Paths.get("").toAbsolutePath() + java.io.File.separator + file;
    }
    Resource resource = set.getResource(URI.createFileURI(file), true);
    // validate the resource
    List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
    if (!list.isEmpty()) {
      for (Issue issue : list) {
        System.err.println(issue);
      }
      return;
    }
    EObject eo = resource.getAllContents().next();
    if (SpearTypeChecker.ERROR != SpearTypeChecker.typeCheck(eo)) {
      System.out.println("Type checked Eobject: " + eo.toString());
    } else {
      System.out.println("Failed to Type checked Eobject: " + eo.toString());
    }
    SpearUnitChecker.unitCheck(eo);
    System.out.println("Unit checked Eobject: " + eo.toString());

    File f = (File) eo;

    Specification specification = null;
    if (f instanceof Definitions) {
      System.out.println("Cannot analysze a Definitions file" + eo.toString());
      return;
    } else {
      specification = (Specification) f;
    }

    SpearDocument workingCopy = new SpearDocument(specification);
    workingCopy.transform();

    SProgram program = SProgram.build(workingCopy);
    Program p = program.getLogicalConsistency();

    if (PreferencesUtil.getFinalLustreFileOption()) {
      //
    }
    String jkindjarstr = "jkind.jar";
    Path jkindjarpth = null;
    try {
      jkindjarpth = Files.createTempDirectory(null).resolve(jkindjarstr);
      Files.copy(getClass().getClassLoader().getResourceAsStream(jkindjarstr), jkindjarpth);
    } catch (IOException e1) {
      // TODO Auto-generated catch block
      e1.printStackTrace();
    }

    JKindApi api = new JKindApi();
    api.setJKindJar(jkindjarpth.toString());
    PreferencesUtil.configureJKindApi(api);
    api.setIvcReduction();

    if (PreferencesUtil.generalizeCEX()) {
      api.setIntervalGeneralization();
    }

    if (PreferencesUtil.smoothCEX()) {
      api.setSmoothCounterexamples();
    }

    Renaming renaming = new MapRenaming(workingCopy.renamed.get(workingCopy.getMain()), Mode.IDENTITY);
    List<Boolean> invert = p.getMainNode().properties.stream().map(prop -> true).collect(Collectors.toList());
    JKindResult result = new JKindResult("result", p.getMainNode().properties, invert, renaming);
    try {
      api.execute(p, result, new NullProgressMonitor());
    } catch (Exception e) {
      System.err.println(result.getText());
      throw e;
    }
    System.out.println(result.getPropertyResults());

  }

  protected void runGenerator(Arguments pargs) {

  }
}
