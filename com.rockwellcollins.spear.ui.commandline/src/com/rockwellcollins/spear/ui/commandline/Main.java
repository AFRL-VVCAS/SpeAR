/* generated by Xtext
 */
package com.rockwellcollins.spear.ui.commandline;

import java.nio.file.Paths;
import java.nio.file.Path;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;

import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.jface.preference.PreferenceStore;
import org.eclipse.xtext.diagnostics.Severity;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;

import com.beust.jcommander.JCommander;
import com.beust.jcommander.ParameterException;
import com.google.inject.Inject;
import com.google.inject.Injector;
import com.rockwellcollins.spear.Constraint;
import com.rockwellcollins.spear.File;
import com.rockwellcollins.spear.FormalConstraint;
import com.rockwellcollins.spear.Import;
import com.rockwellcollins.spear.Specification;
import com.rockwellcollins.spear.preferences.PreferenceConstants;
import com.rockwellcollins.spear.preferences.Preferences;
import com.rockwellcollins.spear.preferences.PreferencesUtil;
import com.rockwellcollins.spear.translate.intermediate.SpearDocument;
import com.rockwellcollins.spear.translate.master.SProgram;


import jkind.api.JKindApi;
import jkind.api.results.JKindResult;
import jkind.api.results.MapRenaming;
import jkind.api.results.Renaming;
import jkind.api.results.MapRenaming.Mode;
import jkind.api.results.PropertyResult;
import jkind.lustre.Program;

public class Main {

  public static void main(String[] args) {

    Injector injector = new com.rockwellcollins.SpearStandaloneSetup().createInjectorAndDoEMFRegistration();
    Main main = injector.getInstance(Main.class);
    main.runGenerator(args);
  }

  @Inject
  private IResourceValidator    validator;

  protected void runGenerator(String[] args) {

    SpeARMainCommand main = new SpeARMainCommand();
    JCommander jcom = new JCommander(main);
    SpeARjKindCommandEntailment entailment = new SpeARjKindCommandEntailment();
    jcom.addCommand("entailment", entailment);
    SpeARjKindCommandConsistency consistency = new SpeARjKindCommandConsistency();
    jcom.addCommand("consistency", consistency);
    SpeARjRealizabilityCommandRealizability realizability = new SpeARjRealizabilityCommandRealizability();
    jcom.addCommand("realizability", realizability);
    jcom.setProgramName("java -jar spear.jar");

    try {
      jcom.parse(args);
      if(jcom.getParsedCommand() == null) {
        throw new ParameterException("A command must be given.");
      }
    } catch (ParameterException pe) {
      System.err.println(pe.getMessage());
      jcom.usage();
      return;
    }
    
    String command = jcom.getParsedCommand();
    List<java.io.File> specs = null;
    if(command == "entailment") {
      specs = entailment.spec;
    } else if (command == "consistency") {
      specs = consistency.spec;
    } else if (command == "realizability") {
      specs = realizability.spec;
    }
    
    if(specs.size() != 1) {
      System.err.println("Exactly one specification file required for all commands.");
      jcom.usage();
      return;
    }
    
    if(command == "entailment" || command == "consistency") {
      SpeARjKindCommand opts = null;
      PreferenceStore s = Preferences.store;
      if(command == "entailment") {
        opts = entailment;
        s.setValue(PreferenceConstants.PREF_SPEAR_ENABLE_IVC_ON_ENTAILMENT, entailment.ivc);
      } else if (command == "consistency") {
        opts = consistency;
        s.setValue(PreferenceConstants.PREF_SPEAR_CONSISTENCY_DEPTH, consistency.con_depth.intValue());
      } else {
        throw new RuntimeException("This should not happen: unknown command.");
      }
      s.setValue(PreferenceConstants.PREF_MODEL_CHECKER, opts.solver.toString());
      s.setValue(PreferenceConstants.PREF_BOUNDED_MODEL_CHECKING, opts.no_bmc);
      s.setValue(PreferenceConstants.PREF_K_INDUCTION, opts.no_k_induction);
      s.setValue(PreferenceConstants.PREF_INVARIANT_GENERATION, opts.no_inv_gen);
      /*s.setValue(PreferenceConstants.PREF_PDR_MAX, opts.pdr_max);*/
      s.setValue(PreferenceConstants.PREF_INDUCTIVE_COUNTEREXAMPLES, opts.induct_cex);
      s.setValue(PreferenceConstants.PREF_SMOOTH_COUNTEREXAMPLES,opts.smooth);
      s.setValue(PreferenceConstants.PREF_INTERVAL_GENERALIZATION, opts.interval);
      s.setValue(PreferenceConstants.PREF_DEPTH, opts.n.intValue());
      s.setValue(PreferenceConstants.PREF_TIMEOUT, opts.timeout.intValue());

      /*s.setValue(PreferenceConstants.PREF_SPEAR_PRINT_FINAL_LUSTRE, false);*/
      /*s.setDefault(PreferenceConstants.PREF_SPEAR_RECURSIVE_GRAPH, false);*
      /*s.setDefault(PreferenceConstants.PREF_SPEAR_WARN_ON_UNUSED_VARS, false);*/
    } else if (command == "realizability") {
      throw new RuntimeException("This should not happen: unimplemented.");
    }
    
    java.io.File spec = specs.get(0);
    
    // XXX: If an absolute path is not used calls to Utilities.getImportedFile may fail.
    Injector injector = new com.rockwellcollins.SpearStandaloneSetup().createInjectorAndDoEMFRegistration();
    XtextResourceSet resourceSet = injector.getInstance(XtextResourceSet.class);
    resourceSet.addLoadOption(XtextResource.OPTION_RESOLVE_ALL, Boolean.TRUE);
    Resource resource = resourceSet.getResource(URI.createFileURI(spec.getAbsolutePath()), true);
    
    List<Issue> list = new LinkedList<Issue>();
    List<String> visited = new LinkedList<String>();

    validateRecursively(resourceSet,resource,list,visited);
    boolean analysis = true;
    if (!list.isEmpty()) {
      for (Issue issue : list) {
        if(issue.getSeverity() == Severity.ERROR) {
          analysis = false;
        }
        System.err.println(issue);
      }
    }
    if(!analysis) {
      System.err.println("Errors during validation analysis is not possible.");
      return;
    }

    String jkindjarstr = "jkind.jar";
    Path jkindjarpth = null;
    try {
      jkindjarpth = Files.createTempDirectory(null).resolve(jkindjarstr);
      Files.copy(getClass().getClassLoader().getResourceAsStream(jkindjarstr), jkindjarpth);
    } catch (IOException e1) {
      throw new RuntimeException("This should not happen: Problem exporting 'jkind.jar'.");
    }

    JKindApi api = new JKindApi();
    api.setJKindJar(jkindjarpth.toString());
    PreferencesUtil.configureJKindApi(api);
    
    SpearDocument workingCopy = new SpearDocument((Specification) resource.getContents().get(0));
    workingCopy.transform();

    SProgram program = SProgram.build(workingCopy);
    Program p = program.getLogicalEntailment();

    
    if(command == "entailment") {
      
    } else if (command == "consistency") {
      throw new RuntimeException("This should not happen: unimplemented.");
    } else if (command == "realizability") {
      throw new RuntimeException("This should not happen: unimplemented.");
    } else {
      throw new RuntimeException("This should not happen: unknown command.");
    }
    
    Renaming renaming = new MapRenaming(workingCopy.renamed.get(workingCopy.getMain()), Mode.IDENTITY);
    List<Boolean> invert = new ArrayList<>();
    Specification s = workingCopy.specifications.get(workingCopy.mainName);
    for (Constraint c : s.getBehaviors()) {
      if (c instanceof FormalConstraint) {
        FormalConstraint fc = (FormalConstraint) c;
        if (fc.getFlagAsWitness() != null) {
          invert.add(true);
        } else {
          invert.add(false);
        }
      } else {
        invert.add(false);
      }
    }
    JKindResult result = new JKindResult("result", p.getMainNode().properties, invert, renaming);
    try {
      api.execute(p, result, new NullProgressMonitor());
      for( PropertyResult pr : result.getPropertyResults()) {
        System.out.println(pr.toString());
      }
    } catch (Exception e) {
      System.err.println(result.getText());
      throw e;
    }

  }

  private void validateRecursively(XtextResourceSet resourceSet, Resource resource, List<Issue> list, List<String> visited) {
    if(visited.contains(resource.getURI().toString())){
      return;
    }
    visited.add(resource.getURI().toString());
    if(resource.getContents().size()!=1) {
      
      for(org.eclipse.emf.ecore.resource.Resource.Diagnostic d : resource.getErrors()) {
        System.err.println("ERROR:" + d.getMessage() + ". (" + resource.getURI().toString() + " Line : " 
            + d.getLine() +" column : " + d.getColumn() + ")");
      }
      return;
    }
    for ( Import relfilepath : ((File) resource.getContents().get(0)).getImports()) {
      Path path = Paths.get(resource.getURI().devicePath()).getParent().resolve(relfilepath.getImportURI());
      Resource r = null;
      try {
        r = resourceSet.getResource(URI.createFileURI(path.toString()), true);
      } catch (Exception e) {
        continue;
      }
      validateRecursively(resourceSet, r, list, visited);
    }
    List<Issue> extension = null;
    extension = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
    list.addAll(extension);
  }


}
