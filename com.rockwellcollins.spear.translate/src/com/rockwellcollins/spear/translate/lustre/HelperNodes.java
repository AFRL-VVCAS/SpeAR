package com.rockwellcollins.spear.translate.lustre;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import jkind.lustre.Ast;
import jkind.lustre.BinaryExpr;
import jkind.lustre.BinaryOp;
import jkind.lustre.BoolExpr;
import jkind.lustre.Equation;
import jkind.lustre.Expr;
import jkind.lustre.IdExpr;
import jkind.lustre.NamedType;
import jkind.lustre.Node;
import jkind.lustre.UnaryExpr;
import jkind.lustre.UnaryOp;
import jkind.lustre.VarDecl;

/**
 * PLTL is a utility that generates some commonly used PLTL expressions as
 * Lustre node because we need them to generate some of our autogenerated
 * properties.
 */
public class HelperNodes {

	/**
	 * Initially
	 */
	public static Node initially() {
		String name = "initially";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();

		// inputs: signal : bool
		VarDecl signal = new VarDecl("signal", NamedType.BOOL);

		// outputs: holds : bool
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);

		// equations: holds = signal -> true
		Equation equation = new Equation(new IdExpr(holds.id), new BinaryExpr(new IdExpr(signal.id), BinaryOp.ARROW, new BoolExpr(true)));

		inputs.add(signal);
		outputs.add(holds);
		equations.add(equation);

		return new Node(name, inputs, outputs, locals, equations);
	}
	
	/**
	 * Historically EXPR must be true on the current step and every previous step.
	 */
	public static Node historically() {
		String name = "historically";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();

		// inputs: signal : bool
		VarDecl signal = new VarDecl("signal", NamedType.BOOL);

		// outputs: holds : bool
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);

		// equations: holds = signal and (true -> pre holds);
		Equation equation = new Equation(new IdExpr(holds.id), new BinaryExpr(new IdExpr(signal.id), BinaryOp.AND,
				new BinaryExpr(new BoolExpr(true), BinaryOp.ARROW, new UnaryExpr(UnaryOp.PRE, new IdExpr(holds.id)))));

		inputs.add(signal);
		outputs.add(holds);
		equations.add(equation);

		return new Node(name, inputs, outputs, locals, equations);
	}

	/**
	 * O is the node that implements Once. Once EXPR must be true at least once
	 * on the current step and every previous step.
	 */
	public static Node once() {
		String name = "once";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();

		// inputs: signal : bool
		VarDecl signal = new VarDecl("signal", NamedType.BOOL);

		// outputs: holds : bool
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);

		// equations: holds = signal or (false -> pre holds);
		Equation equation = new Equation(new IdExpr(holds.id), new BinaryExpr(new IdExpr(signal.id), BinaryOp.OR,
				new BinaryExpr(new BoolExpr(false), BinaryOp.ARROW, new UnaryExpr(UnaryOp.PRE, new IdExpr(holds.id)))));

		inputs.add(signal);
		outputs.add(holds);
		equations.add(equation);

		return new Node(name, inputs, outputs, locals, equations);
	}

	/**
	 * S is the node that implements Since.
	 */
	public static Node since() {
		String name = "since";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();

		// inputs: a : bool; b : bool;
		VarDecl a = new VarDecl("a", NamedType.BOOL);
		VarDecl b = new VarDecl("b", NamedType.BOOL);

		// outputs: holds : bool
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);

		// equations: holds = b or (a and (false -> pre holds))
		Equation equation = new Equation(new IdExpr(holds.id),
				new BinaryExpr(new IdExpr(b.id), BinaryOp.OR,
						new BinaryExpr(new IdExpr(a.id), BinaryOp.AND, new BinaryExpr(new BoolExpr(false),
								BinaryOp.ARROW, new UnaryExpr(UnaryOp.PRE, new IdExpr(holds.id))))));

		inputs.add(a);
		inputs.add(b);

		outputs.add(holds);
		equations.add(equation);

		return new Node(name, inputs, outputs, locals, equations);
	}

	/**
	 * T is the node that implements Trigger
	 */
	public static Node triggers() {
		String name = "triggers";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();

		// inputs
		VarDecl a = new VarDecl("a", NamedType.BOOL);
		VarDecl b = new VarDecl("b", NamedType.BOOL);

		// outputs
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);

		List<Expr> args = new ArrayList<>();
		args.add(new IdExpr(holds.id));

		// equations: holds = b and (a or (true -> pre holds))
		Equation equation = new Equation(new IdExpr(holds.id),
				new BinaryExpr(new IdExpr(b.id), BinaryOp.AND,
						new BinaryExpr(new IdExpr(a.id), BinaryOp.OR, new BinaryExpr(new BoolExpr(true), BinaryOp.ARROW,
								new UnaryExpr(UnaryOp.PRE, new IdExpr(holds.id))))));

		inputs.add(a);
		inputs.add(b);

		outputs.add(holds);
		equations.add(equation);

		return new Node(name, inputs, outputs, locals, equations);
	}

	/**
	 * T is the node that implements Trigger
	 */
	public static Node triggers_alt() {
		String name = "triggers_alt";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();

		// inputs: a : bool; b : bool
		VarDecl a = new VarDecl("a", NamedType.BOOL);
		VarDecl b = new VarDecl("b", NamedType.BOOL);

		// outputs: holds : bool
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);

		// equations: holds = b and (a or (false -> pre holds))
		Equation equation = new Equation(new IdExpr(holds.id),
				new BinaryExpr(new IdExpr(b.id), BinaryOp.AND,
						new BinaryExpr(new IdExpr(a.id), BinaryOp.OR, new BinaryExpr(new BoolExpr(false), BinaryOp.ARROW,
								new UnaryExpr(UnaryOp.PRE, new IdExpr(holds.id))))));

		inputs.add(a);
		inputs.add(b);

		outputs.add(holds);
		equations.add(equation);

		return new Node(name, inputs, outputs, locals, equations);
	}

	public static Map<String, Ast> getPLTL() {
		List<Node> nodes = new ArrayList<>();
		Map<String, Ast> map = new HashMap<>();

		nodes.add(historically());
		nodes.add(once());
		nodes.add(since());
		nodes.add(triggers());
		nodes.add(triggers_alt());

		for (Node n : nodes) {
			map.put(n.id, n);
		}

		return map;
	}
}
